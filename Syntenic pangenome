##Perfomr all vs all protein alignment for 126 pangenomes including reference genome
diamond blastp -q DDD.pep.fa -d ${i}.pep.fa -o DDD${i}_results.txt -e 1 -f 6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle -k 1 -p 80
## Syntenic pagenome construction
# The installation pipline of mSynOths is at gitee(https://gitee.com/zhanglingkui/msynorths/)

# Identification of synteny gene families
python ~/180T/msynorths_gitee/mSynOrths.py -t 60 -o Cucum_137_0110 -m 0.8 -v 0.5 -i 85  -f genome_pos.txt -c 

#bulit gene-level pangenome for cucumber genomes
python bulit_pangenome.py -m Cucum_137_0110 -o Cucum_137_0110_pangene.txt



bulit_pangenome.py:
# -*- coding=utf-8 -*-
import sys
import os
import argparse
import re
parser = argparse.ArgumentParser(description='pangenome')
parser.add_argument('-m', type=str, help='output folder of mSynOrths')
parser.add_argument('-f', type=str, default='mSynF1', help='choose frame of  pan genome ')
parser.add_argument('-o', type=str, default='pangenome.txt', help='output file')
# parser.add_argument('-c', "--continuedo", action='store_true',)
args = parser.parse_args()
msyn_fold,frame_fold,out_file=args.m,args.f,args.o

# species num. of mSynOrths
msynf_num=0
# To find the longest gene as representative
total_gene_length_dict={}
# The list dictionary of all genes was constructed to be used to facilitate subsequent queries of upstream and downstream genes
total_gene_list_dict={}
for i in os.listdir(msyn_fold):
    if i.startswith('mSynF'):
        msynf_num+=1
        op_file=open(msyn_fold+'/'+i+'/species.gff_pos')
        index=0
        total_gene_list_dict[i[5:]]=[]
        for line in op_file:
            index+=1
            line_list=line.strip().split('\t')
            total_gene_length_dict[line_list[0]]=int(line_list[2])
            total_gene_list_dict[i[5:]].append(line_list[0])
        op_file.close()


frame_gene_list=[]
frame_fold_path=msyn_fold+'/'+frame_fold+'/'
frame_file=frame_fold_path+'species.gff_pos_DelTandem'
op_frame_file=open(frame_file,'r')
frame_gene_dict={}
index=0
for line in op_frame_file:
    index+=1
    line_list=line.strip().split('\t')
    frame_gene_list.append(line_list[0])
    # index length chr
    frame_gene_dict[line_list[0]]=[index,int(line_list[2]),line_list[3]]
op_frame_file.close()

frame_num=frame_fold[5:]
# bulit a dict containing all synteninc gene with frame gene,
total_syn_frame_dict={}
for i in os.listdir(msyn_fold):
    if i.startswith('mSynF'):
        if int(i[5:])<int(frame_num):
            for x in os.listdir(msyn_fold+'/'+i):
                if x.endswith('syn.seg'):
                    if re.findall('\d+',x)[1]==frame_num:
                        op_file=open(msyn_fold+'/'+i+'/'+x,'r')
                        for line in op_file:
                            if line.startswith('##'):
                                continue
                            line_list=line.strip().split('\t')
                            total_syn_frame_dict[line_list[0]]=line_list[1]
                        op_file.close()
        elif int(i[5:])==int(frame_num):
            for x in os.listdir(msyn_fold+'/'+i):
                if x.endswith('syn.seg'):
                    op_file=open(msyn_fold+'/'+i+'/'+x,'r')
                    for line in op_file:
                        if line.startswith('##'):
                            continue
                        line_list=line.strip().split('\t')
                        total_syn_frame_dict[line_list[1]]=line_list[0]
                    op_file.close()

msyn_file=msyn_fold+'/Total_species_syntenic_gene_pairs.txt'
index=0
op_msyn_file=open(msyn_file,'r')
for line in op_msyn_file:
    line_list=line.strip().split('\t')
    line_dict={}
    for i in range(1,msynf_num+1):
        line_dict[str(i)]=[]
    num_index=0
    for i in line_list:
        # if i.split(':')[0]=='9':
        #     continue
        ad_list=i[len(i.split(':')[0])+1:].split(',')
        ad_list.remove('')
        num_index+=1
        line_dict[i.split(':')[0]]=ad_list
    # filter out synteinc gene family with species num.  fewer than 2
    # if num_index<2:
    #     continue
    #  frame gene in syntenic gene family
    if len(line_dict[frame_num])>0:
        sort_gene_list=sorted(line_dict[frame_num],key=lambda x:frame_gene_dict[x][1],reverse=True)
        frame_gene=sort_gene_list[0]
        frame_gene_dict[frame_gene].append(line_dict)
    # find a longest gene as representive(frame gene)
    else:
        big_length=0
        big_gene=''
        big_key=''
        for key,value in line_dict.items():
            if len(value)>0:
                for gene_id in value:
                    if total_gene_length_dict[gene_id]>big_length:
                        big_length=total_gene_length_dict[gene_id]
                        big_gene=gene_id
                        big_key=key
        big_gene_index=total_gene_list_dict[big_key].index(big_gene)
        for flank_gene in total_gene_list_dict[big_key][big_gene_index::]:
            if flank_gene in total_syn_frame_dict.keys():
                add_index=frame_gene_dict[total_syn_frame_dict[flank_gene]][0]+0.1
                add_chr=frame_gene_dict[total_syn_frame_dict[flank_gene]][2]
                frame_gene_dict[big_gene]=[add_index,big_length,add_chr,line_dict]
                break
op_msyn_file.close()
wr_out_file=open(out_file,'w')
for pan_gene_key in sorted(frame_gene_dict, key=lambda x:frame_gene_dict[x][0]):
    pan_gene_line=frame_gene_dict[pan_gene_key]
    if len(pan_gene_line)>3:
        wr_out_file.write(pan_gene_key+'\t')
        for pan_gene in pan_gene_line[:3]:
            wr_out_file.write(str(pan_gene)+'\t')
        if len(pan_gene_line)>3:
            for i in range(1,int(msynf_num)+1):
                #print(i,pan_gene_line)
                if len(pan_gene_line[-1][str(i)])>1:
                    for x in pan_gene_line[-1][str(i)]:
                        wr_out_file.write(x+',')
                elif len(pan_gene_line[-1][str(i)])==1:
                    wr_out_file.write(pan_gene_line[-1][str(i)][0])
                else:
                    wr_out_file.write('-')
                wr_out_file.write('\t')
            wr_out_file.write('\n')
    # else:
    #     wr_out_file.write('\n')




## Script for calculate Nei's diversity index for haplotype
python haplotype.diversity.py

#!/usr/bin/env python3
"""
Haplotype Diversity Analysis - Nei's Diversity Index

Calculate haplotype diversity for each gene in each group and perform inter-group comparisons.

Nei's diversity index (gene diversity):
H = 1 - Σ(pi^2)
where pi is the frequency of the i-th haplotype

Input:
  - Haplotype data file (homology.haplotype.table.all.input)

Output:
  - Diversity values for each gene in each group
  - Density distribution plots
  - Statistical tests for inter-group differences

Date: 2025-12-09
Version: 1.0
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from scipy.stats import false_discovery_control
import argparse
import sys
import warnings
warnings.filterwarnings('ignore')

# Set font for plotting
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'DejaVu Sans', 'SimHei']
plt.rcParams['axes.unicode_minus'] = False

def calculate_nei_diversity(haplotypes):
    """
    Calculate Nei's diversity index

    Parameters:
        haplotypes: List of haplotypes

    Returns:
        float: Nei's diversity (0-1)
    """
    # Remove missing values
    haplotypes = [h for h in haplotypes if not pd.isna(h)]

    if len(haplotypes) < 2:
        return np.nan

    # Calculate frequency of each haplotype
    unique, counts = np.unique(haplotypes, return_counts=True)
    frequencies = counts / len(haplotypes)

    # Nei's diversity: H = 1 - Σ(pi^2)
    diversity = 1.0 - np.sum(frequencies ** 2)

    return diversity

def calculate_diversity_for_group(data, group_name):
    """
    Calculate diversity for all genes in a group

    Parameters:
        data: DataFrame, haplotype data for the group
        group_name: Group name

    Returns:
        dict: {gene: diversity_value}
    """
    diversities = {}

    for gene in data.columns:
        if gene not in ['Sample', 'Group']:
            diversity = calculate_nei_diversity(data[gene].values)
            if not np.isnan(diversity):
                diversities[gene] = diversity

    return diversities

def parse_args():
    parser = argparse.ArgumentParser(
        description='Calculate haplotype diversity (Nei\'s diversity) and compare inter-group differences',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage
  python %(prog)s -i homology.haplotype.table.all.input -o diversity_result

  # Specify minimum sample size
  python %(prog)s -i data.tab -o result --min-samples 5

  # Customize plot style
  python %(prog)s -i data.tab -o result --style seaborn --colors Set2
        """
    )

    parser.add_argument('-i', '--input', required=True,
                       help='Haplotype data file (tab-delimited)')
    parser.add_argument('-o', '--output', required=True,
                       help='Output file prefix (without extension)')

    parser.add_argument('--min-samples', type=int, default=3,
                       help='Minimum sample size per group (default: 3)')
    parser.add_argument('--min-haplotypes', type=int, default=2,
                       help='Minimum number of haplotypes per gene (default: 2)')

    parser.add_argument('--style', default='seaborn',
                       choices=['seaborn', 'ggplot', 'bmh', 'classic'],
                       help='Plot style (default: seaborn)')
    parser.add_argument('--colors', default='Set2',
                       help='Color scheme (default: Set2)')
    parser.add_argument('--figsize', nargs=2, type=float, default=[10, 6],
                       help='Figure size (width height, default: 10 6)')
    parser.add_argument('--dpi', type=int, default=600,
                       help='Figure resolution (default: 600, Nature standard)')

    return parser.parse_args()

def main():
    args = parse_args()

    print("=" * 70)
    print("Haplotype Diversity Analysis - Nei's Diversity Index")
    print("=" * 70)
    print(f"Input file: {args.input}")
    print(f"Output prefix: {args.output}")
    print(f"Minimum samples/group: {args.min_samples}")
    print(f"Minimum haplotypes/gene: {args.min_haplotypes}")
    print("=" * 70)

    # Read data
    print("\n[1/6] Reading data...")
    try:
        data = pd.read_csv(args.input, sep='\t')
    except Exception as e:
        print(f"Error: Cannot read file - {e}")
        sys.exit(1)

    # Detect sample column
    sample_col = None
    for col in ['Sample', 'sample', 'ID', 'id', 'SampleID']:
        if col in data.columns:
            sample_col = col
            break

    if sample_col is None:
        sample_col = data.columns[0]
        print(f"    Warning: Using first column '{sample_col}' as sample column")

    # Check Group column
    if 'Group' not in data.columns:
        print("Error: No 'Group' column in data")
        sys.exit(1)

    # Standardize column names
    data = data.rename(columns={sample_col: 'Sample'})

    print(f"    Number of samples: {len(data)}")
    print(f"    Number of genes: {data.shape[1] - 2}")

    # Get groups
    groups = data['Group'].unique()
    print(f"    Number of groups: {len(groups)}")
    for group in groups:
        n = len(data[data['Group'] == group])
        print(f"      {group}: {n} samples")

    # Filter groups with insufficient samples
    valid_groups = []
    for group in groups:
        if len(data[data['Group'] == group]) >= args.min_samples:
            valid_groups.append(group)
        else:
            print(f"    Warning: Group '{group}' has insufficient samples, excluded")

    if len(valid_groups) < 2:
        print("Error: At least 2 groups required for comparison")
        sys.exit(1)

    groups = valid_groups
    print(f"    Retained {len(groups)} groups for analysis")

    # Calculate diversity for each group
    print("\n[2/6] Calculating haplotype diversity...")

    all_diversities = {}
    gene_cols = [c for c in data.columns if c not in ['Sample', 'Group']]

    for group in groups:
        print(f"    Processing group: {group}")
        group_data = data[data['Group'] == group]
        diversities = calculate_diversity_for_group(group_data, group)
        all_diversities[group] = diversities
        print(f"      Valid genes: {len(diversities)}/{len(gene_cols)}")

    # Create diversity dataframe
    print("\n[3/6] Organizing data...")

    # Find genes common to all groups
    common_genes = set(all_diversities[groups[0]].keys())
    for group in groups[1:]:
        common_genes &= set(all_diversities[group].keys())

    print(f"    Genes common to all groups: {len(common_genes)}")

    # Create long-format dataframe
    diversity_data = []
    for group in groups:
        for gene in common_genes:
            diversity_data.append({
                'Gene': gene,
                'Group': group,
                'Diversity': all_diversities[group][gene]
            })

    df_diversity = pd.DataFrame(diversity_data)

    # Save detailed results
    output_file = f"{args.output}_diversity.txt"

    # Create wide format for output
    df_wide = df_diversity.pivot(index='Gene', columns='Group', values='Diversity')
    df_wide = df_wide.round(6)

    # Add statistics
    df_wide['Mean'] = df_wide.mean(axis=1)
    df_wide['SD'] = df_wide.std(axis=1)
    df_wide['CV'] = df_wide['SD'] / df_wide['Mean']  # Coefficient of variation

    df_wide.to_csv(output_file, sep='\t')
    print(f"    Diversity data saved: {output_file}")

    # Statistical tests
    print("\n[4/6] Statistical testing...")

    # Calculate descriptive statistics for each group
    summary_stats = df_diversity.groupby('Group')['Diversity'].agg([
        ('N', 'count'),
        ('Mean', 'mean'),
        ('SD', 'std'),
        ('Median', 'median'),
        ('Min', 'min'),
        ('Max', 'max')
    ]).round(6)

    print("\nGroup summary statistics:")
    print(summary_stats)

    # Kruskal-Wallis test (non-parametric)
    group_values = [df_diversity[df_diversity['Group'] == g]['Diversity'].values
                    for g in groups]

    if len(groups) > 2:
        h_stat, p_value = stats.kruskal(*group_values)
        print(f"\nKruskal-Wallis test:")
        print(f"  H statistic: {h_stat:.4f}")
        print(f"  p-value: {p_value:.6e}")
        if p_value < 0.05:
            print(f"  Conclusion: Significant difference in diversity among groups (p < 0.05) ✓")
        else:
            print(f"  Conclusion: No significant difference in diversity among groups (p >= 0.05)")

    # Pairwise comparisons (Mann-Whitney U test)
    print("\nPairwise comparisons (Mann-Whitney U test):")
    pairwise_results = []

    from itertools import combinations
    for g1, g2 in combinations(groups, 2):
        values1 = df_diversity[df_diversity['Group'] == g1]['Diversity'].values
        values2 = df_diversity[df_diversity['Group'] == g2]['Diversity'].values

        u_stat, p_value = stats.mannwhitneyu(values1, values2, alternative='two-sided')

        mean1 = np.mean(values1)
        mean2 = np.mean(values2)
        diff = mean1 - mean2

        pairwise_results.append({
            'Group1': g1,
            'Group2': g2,
            'Mean1': mean1,
            'Mean2': mean2,
            'Difference': diff,
            'U_statistic': u_stat,
            'P_value': p_value,
            'Significant': 'Yes' if p_value < 0.05 else 'No'
        })

        sig_mark = '***' if p_value < 0.001 else '**' if p_value < 0.01 else '*' if p_value < 0.05 else 'ns'
        print(f"  {g1} vs {g2}: p={p_value:.6e} ({sig_mark})")
        print(f"    Mean: {mean1:.4f} vs {mean2:.4f}, Difference: {diff:+.4f}")

    # FDR correction (Benjamini-Hochberg)
    print("\nApplying FDR correction (Benjamini-Hochberg)...")
    p_values = [r['P_value'] for r in pairwise_results]
    p_adjusted = false_discovery_control(np.array(p_values), method='bh')

    for i, r in enumerate(pairwise_results):
        r['P_adjusted'] = p_adjusted[i]
        r['Significant_FDR'] = 'Yes' if p_adjusted[i] < 0.05 else 'No'

    # Calculate multiple comparison letter labels (using FDR-adjusted p-values)
    print("\nCalculating multiple comparison letter labels...")

    # Build significance matrix
    sig_matrix = {}
    for g1, g2 in combinations(groups, 2):
        # Find corresponding comparison result
        for r in pairwise_results:
            if (r['Group1'] == g1 and r['Group2'] == g2) or \
               (r['Group1'] == g2 and r['Group2'] == g1):
                is_sig = r['P_adjusted'] < 0.05  # Use FDR-adjusted p-value
                sig_matrix[(g1, g2)] = is_sig
                sig_matrix[(g2, g1)] = is_sig
                break

    # Calculate letter labels
    group_means = {g: df_diversity[df_diversity['Group'] == g]['Diversity'].mean()
                   for g in groups}
    sorted_groups = sorted(groups, key=lambda x: group_means[x], reverse=True)

    letters = {}
    available_letters = list('abcdefghijklmnopqrstuvwxyz')
    letter_idx = 0

    # Assign letters to each group
    for i, group in enumerate(sorted_groups):
        # Find all groups with no significant difference from current group
        non_sig_groups = [group]
        for other in sorted_groups:
            if other != group and not sig_matrix.get((group, other), False):
                non_sig_groups.append(other)

        # Check existing letters for these groups
        existing_letters = set()
        for g in non_sig_groups:
            if g in letters:
                existing_letters.update(letters[g])

        # If existing letters found, use the smallest one
        if existing_letters:
            letters[group] = min(existing_letters)
        else:
            # Assign new letter
            if letter_idx < len(available_letters):
                letters[group] = available_letters[letter_idx]
                letter_idx += 1
            else:
                letters[group] = 'z'

    # Validate: groups with significant differences must have different letters
    for g1, g2 in combinations(sorted_groups, 2):
        if sig_matrix.get((g1, g2), False):
            if letters[g1] == letters[g2]:
                # Assign new letter to group with smaller mean
                smaller = g1 if group_means[g1] < group_means[g2] else g2
                if letter_idx < len(available_letters):
                    letters[smaller] = available_letters[letter_idx]
                    letter_idx += 1

    print("  Multiple comparison letter labels:")
    for group in sorted_groups:
        print(f"    {group}: {letters[group]} (mean={group_means[group]:.4f})")

    # Save pairwise comparison results
    df_pairwise = pd.DataFrame(pairwise_results)
    pairwise_file = f"{args.output}_pairwise_comparison.txt"
    df_pairwise.to_csv(pairwise_file, sep='\t', index=False, float_format='%.6f')
    print(f"\nPairwise comparison results saved: {pairwise_file}")

    # Plotting
    print("\n[5/6] Creating plots...")

    # Save plotting data
    print("    Saving plot data...")
    plot_data_file = f"{args.output}_plot_data.txt"

    plot_data_list = []
    for group in groups:
        group_values = df_diversity[df_diversity['Group'] == group]['Diversity'].values
        for val in group_values:
            plot_data_list.append({
                'Group': group,
                'Diversity': val
            })

    plot_data_df = pd.DataFrame(plot_data_list)

    # Add statistical information
    stats_df = pd.DataFrame({
        'Group': groups,
        'N': [len(df_diversity[df_diversity['Group'] == g]) for g in groups],
        'Mean': [df_diversity[df_diversity['Group'] == g]['Diversity'].mean() for g in groups],
        'SD': [df_diversity[df_diversity['Group'] == g]['Diversity'].std() for g in groups],
        'SEM': [df_diversity[df_diversity['Group'] == g]['Diversity'].sem() for g in groups],
        'Letter': [letters[g] for g in groups]
    })

    # Save as two sections: raw data and statistics
    with open(plot_data_file, 'w') as f:
        f.write("# Raw data\n")
        plot_data_df.to_csv(f, sep='\t', index=False)
        f.write("\n# Summary statistics\n")
        stats_df.to_csv(f, sep='\t', index=False)

    print(f"    Plot data saved: {plot_data_file}")

    # Set style - minimalist
    plt.style.use('default')

    # Set font and parameters
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.size'] = 10
    plt.rcParams['axes.linewidth'] = 1
    plt.rcParams['xtick.major.width'] = 1
    plt.rcParams['ytick.major.width'] = 1
    plt.rcParams['xtick.major.size'] = 4
    plt.rcParams['ytick.major.size'] = 4
    plt.rcParams['pdf.fonttype'] = 42
    plt.rcParams['ps.fonttype'] = 42

    # Simple color scheme - primarily grayscale
    simple_colors = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D',
                     '#6A994E', '#BC4B51', '#5E60CE', '#8D99AE']

    if len(groups) <= len(simple_colors):
        colors = simple_colors[:len(groups)]
    else:
        colors = plt.cm.tab10(np.linspace(0, 1, len(groups)))

    # Create single plot - minimalist design
    fig, ax = plt.subplots(figsize=(6, 4.5))

    positions = np.arange(len(groups))

    # Only boxplot + data points, minimalist style
    bp = ax.boxplot([df_diversity[df_diversity['Group'] == g]['Diversity'].values
                      for g in groups],
                     positions=positions,
                     widths=0.5,
                     patch_artist=True,
                     showfliers=False,
                     medianprops=dict(color='white', linewidth=2),
                     boxprops=dict(linewidth=1.5),
                     whiskerprops=dict(linewidth=1.5),
                     capprops=dict(linewidth=1.5))

    # Set box colors
    for patch, color in zip(bp['boxes'], colors):
        patch.set_facecolor(color)
        patch.set_alpha(0.8)
        patch.set_edgecolor('black')

    # Overlay data points - more transparent
    for i, group in enumerate(groups):
        group_data = df_diversity[df_diversity['Group'] == group]['Diversity'].values
        x_jitter = np.random.normal(i, 0.04, size=len(group_data))

        ax.scatter(x_jitter, group_data,
                  color='black',  # Uniform black
                  s=20,
                  alpha=0.3,
                  zorder=3)

    # Add letter labels - minimalist style
    y_max = df_diversity['Diversity'].max()
    y_min = df_diversity['Diversity'].min()
    y_range = y_max - y_min

    for i, group in enumerate(groups):
        letter = letters[group]
        # Simple letters, no borders
        ax.text(i, y_max + y_range * 0.08, letter,
               ha='center', va='bottom',
               fontsize=14, fontweight='bold',
               color='black')

    # Minimalist axis settings
    ax.set_xticks(positions)
    ax.set_xticklabels(groups, fontsize=11)
    ax.set_ylabel("Nei's Diversity Index", fontsize=12, fontweight='bold')
    ax.set_ylim(max(0, y_min - y_range * 0.1), y_max + y_range * 0.2)

    # Only keep left and bottom spines
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_linewidth(1)
    ax.spines['bottom'].set_linewidth(1)

    # No grid - minimalist
    ax.set_axisbelow(True)

    # Tight layout
    plt.tight_layout()

    # Save plot
    plot_file = f"{args.output}_diversity_plot.pdf"
    plt.savefig(plot_file, dpi=args.dpi, bbox_inches='tight',
                format='pdf', transparent=False)
    print(f"    Plot saved: {plot_file}")

    plt.close()

    # Generate report
    print("\n[6/6] Generating analysis report...")
    report_file = f"{args.output}_report.txt"

    with open(report_file, 'w') as f:
        f.write("=" * 70 + "\n")
        f.write("Haplotype Diversity Analysis Report - Nei's Diversity Index\n")
        f.write("=" * 70 + "\n\n")

        f.write(f"Input file: {args.input}\n")
        f.write(f"Analysis date: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

        f.write("=" * 70 + "\n")
        f.write("Data Overview\n")
        f.write("=" * 70 + "\n")
        f.write(f"Total samples: {len(data)}\n")
        f.write(f"Total genes: {len(gene_cols)}\n")
        f.write(f"Number of groups: {len(groups)}\n")
        f.write(f"Genes analyzed: {len(common_genes)}\n\n")

        for group in groups:
            n = len(data[data['Group'] == group])
            f.write(f"  {group}: {n} samples\n")

        f.write("\n" + "=" * 70 + "\n")
        f.write("Group Diversity Statistics\n")
        f.write("=" * 70 + "\n\n")
        f.write(summary_stats.to_string())
        f.write("\n\n")

        f.write("=" * 70 + "\n")
        f.write("Multiple Comparison Letter Labels (FDR-adjusted)\n")
        f.write("=" * 70 + "\n")
        f.write("Different letters indicate significant difference between groups (FDR < 0.05)\n")
        f.write("Same letters indicate no significant difference\n\n")
        for group in sorted(letters.keys(), key=lambda x: group_means[x], reverse=True):
            f.write(f"  {group}: {letters[group]}  (mean = {group_means[group]:.6f})\n")
        f.write("\n")

        if len(groups) > 2:
            f.write("=" * 70 + "\n")
            f.write("Kruskal-Wallis Test (Overall Comparison)\n")
            f.write("=" * 70 + "\n")
            f.write(f"H statistic: {h_stat:.4f}\n")
            f.write(f"p-value: {p_value:.6e}\n")
            if p_value < 0.05:
                f.write("Conclusion: Significant difference in diversity among groups (p < 0.05) ✓\n\n")
            else:
                f.write("Conclusion: No significant difference in diversity among groups (p >= 0.05)\n\n")

        f.write("=" * 70 + "\n")
        f.write("Pairwise Comparisons (Mann-Whitney U Test + FDR Correction)\n")
        f.write("=" * 70 + "\n\n")

        for comp in pairwise_results:
            sig_mark_raw = '***' if comp['P_value'] < 0.001 else '**' if comp['P_value'] < 0.01 else '*' if comp['P_value'] < 0.05 else 'ns'
            sig_mark_fdr = '***' if comp['P_adjusted'] < 0.001 else '**' if comp['P_adjusted'] < 0.01 else '*' if comp['P_adjusted'] < 0.05 else 'ns'
            f.write(f"{comp['Group1']} vs {comp['Group2']}:\n")
            f.write(f"  Mean: {comp['Mean1']:.6f} vs {comp['Mean2']:.6f}\n")
            f.write(f"  Difference: {comp['Difference']:+.6f}\n")
            f.write(f"  U statistic: {comp['U_statistic']:.2f}\n")
            f.write(f"  Raw p-value: {comp['P_value']:.6e} ({sig_mark_raw})\n")
            f.write(f"  FDR-adjusted p-value: {comp['P_adjusted']:.6e} ({sig_mark_fdr})\n")
            f.write(f"  Significance (FDR): {comp['Significant_FDR']}\n\n")

        f.write("=" * 70 + "\n")
        f.write("Interpretation\n")
        f.write("=" * 70 + "\n")
        f.write("Nei's Diversity Index (H):\n")
        f.write("  Range: 0-1\n")
        f.write("  H = 1 - Σ(pi^2), where pi is the frequency of the i-th haplotype\n")
        f.write("  H = 0: No diversity (all samples have the same haplotype)\n")
        f.write("  H = 1: Maximum diversity (all samples have different haplotypes)\n\n")
        f.write("Significance levels:\n")
        f.write("  ***: p < 0.001 (extremely significant)\n")
        f.write("  **:  p < 0.01  (very significant)\n")
        f.write("  *:   p < 0.05  (significant)\n")
        f.write("  ns:  p >= 0.05 (not significant)\n")

    print(f"    Analysis report saved: {report_file}")

    print("\n" + "=" * 70)
    print("Analysis complete!")
    print("=" * 70)
    print("Output files:")
    print(f"  1. Diversity data: {output_file}")
    print(f"  2. Pairwise comparisons: {pairwise_file}")
    print(f"  3. Plot data: {plot_data_file}")
    print(f"  4. Plot: {plot_file}")
    print(f"  5. Report: {report_file}")
    print("=" * 70)

if __name__ == '__main__':
    main()






